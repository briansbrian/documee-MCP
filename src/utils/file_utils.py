"""File utility functions for file operations and ID generation."""

import os
import hashlib
from typing import Optional


def calculate_file_size(file_path: str) -> int:
    """
    Calculate the size of a file in bytes.
    
    Args:
        file_path: Path to the file
        
    Returns:
        File size in bytes
        
    Raises:
        FileNotFoundError: If the file does not exist
        OSError: If there's an error accessing the file
    """
    try:
        return os.path.getsize(file_path)
    except FileNotFoundError:
        raise FileNotFoundError(f"File not found: {file_path}")
    except OSError as e:
        raise OSError(f"Error accessing file {file_path}: {e}")


def calculate_directory_size(directory_path: str) -> int:
    """
    Calculate the total size of all files in a directory recursively.
    
    Args:
        directory_path: Path to the directory
        
    Returns:
        Total size in bytes
        
    Raises:
        NotADirectoryError: If the path is not a directory
    """
    if not os.path.isdir(directory_path):
        raise NotADirectoryError(f"Not a directory: {directory_path}")
    
    total_size = 0
    try:
        for dirpath, dirnames, filenames in os.walk(directory_path):
            for filename in filenames:
                file_path = os.path.join(dirpath, filename)
                try:
                    total_size += os.path.getsize(file_path)
                except (OSError, FileNotFoundError):
                    # Skip files that can't be accessed
                    continue
    except OSError:
        # If we can't walk the directory, return what we have so far
        pass
    
    return total_size


def bytes_to_mb(bytes_size: int) -> float:
    """
    Convert bytes to megabytes.
    
    Args:
        bytes_size: Size in bytes
        
    Returns:
        Size in megabytes (rounded to 2 decimal places)
    """
    return round(bytes_size / (1024 * 1024), 2)


def generate_codebase_id(path: str) -> str:
    """
    Generate a unique codebase ID using SHA-256 hash of the absolute path.
    
    The ID is generated by:
    1. Converting the path to an absolute path
    2. Normalizing path separators for consistency
    3. Computing SHA-256 hash of the path
    4. Truncating to 16 characters
    
    Args:
        path: Directory path for the codebase
        
    Returns:
        16-character unique identifier
        
    Examples:
        >>> generate_codebase_id("/home/user/project")
        "a1b2c3d4e5f6g7h8"
        
        >>> generate_codebase_id("C:\\Users\\project")
        "x9y8z7w6v5u4t3s2"
    """
    # Convert to absolute path for consistency
    abs_path = os.path.abspath(path)
    
    # Normalize path separators to forward slashes for consistent hashing
    # across different OS (Windows vs Unix)
    normalized_path = abs_path.replace("\\", "/")
    
    # Generate SHA-256 hash
    hash_object = hashlib.sha256(normalized_path.encode('utf-8'))
    hash_hex = hash_object.hexdigest()
    
    # Truncate to 16 characters
    return hash_hex[:16]


def generate_feature_id(directory_path: str) -> str:
    """
    Generate a unique feature ID using SHA-256 hash of the directory path.
    
    The ID is generated by:
    1. Converting the path to an absolute path
    2. Normalizing path separators for consistency
    3. Computing SHA-256 hash of the path
    4. Truncating to 16 characters
    
    Args:
        directory_path: Path to the feature directory
        
    Returns:
        16-character unique identifier
        
    Examples:
        >>> generate_feature_id("/home/user/project/src/routes")
        "f1e2d3c4b5a69788"
        
        >>> generate_feature_id("C:\\Users\\project\\src\\components")
        "9a8b7c6d5e4f3210"
    """
    # Convert to absolute path for consistency
    abs_path = os.path.abspath(directory_path)
    
    # Normalize path separators to forward slashes for consistent hashing
    # across different OS (Windows vs Unix)
    normalized_path = abs_path.replace("\\", "/")
    
    # Generate SHA-256 hash
    hash_object = hashlib.sha256(normalized_path.encode('utf-8'))
    hash_hex = hash_object.hexdigest()
    
    # Truncate to 16 characters
    return hash_hex[:16]


def is_file_too_large(file_path: str, max_size_mb: int = 10) -> bool:
    """
    Check if a file exceeds the maximum allowed size.
    
    Args:
        file_path: Path to the file
        max_size_mb: Maximum allowed size in megabytes (default: 10MB)
        
    Returns:
        True if file is too large, False otherwise
    """
    try:
        file_size_bytes = calculate_file_size(file_path)
        file_size_mb = bytes_to_mb(file_size_bytes)
        return file_size_mb > max_size_mb
    except (FileNotFoundError, OSError):
        # If we can't access the file, consider it too large to skip it
        return True


def get_file_extension(file_path: str) -> str:
    """
    Get the file extension from a file path.
    
    Args:
        file_path: Path to the file
        
    Returns:
        File extension including the dot (e.g., ".py", ".js")
        Returns empty string if no extension
    """
    _, ext = os.path.splitext(file_path)
    return ext.lower()


def is_text_file(file_path: str) -> bool:
    """
    Check if a file is likely a text file based on its extension.
    
    Args:
        file_path: Path to the file
        
    Returns:
        True if the file appears to be a text file, False otherwise
    """
    text_extensions = {
        '.py', '.js', '.jsx', '.ts', '.tsx', '.java', '.go', '.rs',
        '.rb', '.php', '.cs', '.cpp', '.c', '.h', '.hpp', '.txt',
        '.md', '.json', '.yaml', '.yml', '.xml', '.html', '.css',
        '.scss', '.sass', '.less', '.sql', '.sh', '.bash', '.toml',
        '.ini', '.cfg', '.conf', '.env'
    }
    
    ext = get_file_extension(file_path)
    return ext in text_extensions
